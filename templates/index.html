<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sing-box 配置编辑器</title>
    <style>
        :root {
            --editor-height-ratio: 0.66; /* 编辑器占据屏幕高的2/3 */
            --column-gap: 15px;
            --func-button-min-width: 100px; /* 功能按钮最小宽度 */
            --hierarchy-max-width-ratio: 0.2; /* 配置层级最大宽度占总宽的1/5 */

            /* 移动端特定变量 */
            --mobile-editor-height-ratio: 0.45; /* 移动端编辑器占据屏幕高的约一半 */
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 100vh;
        }
        h1 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 10px;
        }

        /* 提示框样式 */
        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* 允许点击穿透 */
        }
        .toast-notification.show {
            opacity: 1;
        }
        .toast-notification.success {
            background-color: rgba(40, 167, 69, 0.8);
        }
        .toast-notification.error {
            background-color: rgba(220, 53, 69, 0.8);
        }

        /* 配置路径选择器容器 */
        #config-path-selector-container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 600px;
            margin: 50px auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #config-path-selector-container h2 {
            color: #007bff;
            margin-top: 0;
            margin-bottom: 20px;
        }
        #config-path-select, #manual-path-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
            box-sizing: border-box;
            background-color: #f9f9f9;
        }
        #set-path-button {
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            width: 100%;
        }
        #set-path-button:hover {
            background-color: #218838;
        }
        .current-active-path-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }
        .config-path-message {
            color: #dc3545;
            margin-top: 10px;
        }

        /* 主编辑器容器 */
        #main-editor-container {
            flex-grow: 1;
            display: flex;
            gap: var(--column-gap);
            height: calc(100vh * var(--editor-height-ratio));
            align-items: stretch;
        }

        /* 第一列：功能按钮区 - 竖向排列 */
        .functional-buttons-column {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
            overflow-y: auto;
        }
        .functional-buttons-column button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            border: none;
            font-size: 0.95rem;
            text-align: center;
            transition: background-color 0.3s ease, transform 0.1s ease;
            word-break: break-all;
            white-space: normal;
        }
        .functional-buttons-column button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }
        .functional-buttons-column button.active {
            background-color: #28a745;
            box-shadow: 0 0 0 2px #28a745, 0 0 0 4px rgba(40, 167, 69, 0.5);
        }
        .functional-buttons-column .message {
            text-align: left;
            font-size: 0.8em;
            color: #666;
        }

        /* 第二、三、四列的共同样式 */
        .editor-column {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }
        .editor-column h2 {
            color: #555;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            flex-shrink: 0;
        }

        /* 第二列：层级选择器 */
        .hierarchy-selector {
            flex-grow: 0;
            flex-shrink: 0;
            overflow-x: auto;
        }
        .hierarchy-selector ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        .hierarchy-selector li {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: normal;
            word-break: break-all;
        }
        .hierarchy-selector li:last-child {
            border-bottom: none;
        }
        .hierarchy-selector li:hover {
            background-color: #e0f2f7;
        }
        .hierarchy-selector li.active {
            background-color: #cceeff;
            font-weight: bold;
            color: #0056b3;
        }

        /* 第三、四列 (片段编辑器, 完整配置编辑器) 平分剩余宽度 */
        .fragment-editor, .full-config-editor {
            flex-grow: 1;
            flex-basis: 0;
        }

        /* 第三、四列的 textarea */
        textarea {
            width: 100%;
            height: 100%; /* 占据父容器剩余高度 */
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 0.9em;
            box-sizing: border-box;
            resize: vertical;
            font-family: 'Courier New', monospace;
            background-color: #fdfdfd;
        }
        textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        /* 全局保存和重启按钮容器，放在三列之外 */
        #global-action-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        #global-action-buttons button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: background-color 0.3s ease;
            white-space: nowrap;
        }
        #save-config-button {
            background-color: #28a745;
            color: white;
        }
        #save-config-button:hover {
            background-color: #218838;
        }
        #save-and-restart-button {
            background-color: #dc3545;
            color: white;
        }
        #save-and-restart-button:hover {
            background-color: #c82333;
        }
        button:disabled {
            background-color: #cccccc !important;
            cursor: not-allowed !important;
            transform: none !important;
        }

        /* 底部信息 */
        .footer {
            margin-top: auto;
            text-align: center;
            color: #888;
            font-size: 0.9em;
        }
        .message {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        /* 响应式调整 */
        /* 大屏幕 (>= 1200px 默认四列布局，完整配置编辑器显示) */
        @media (min-width: 1200px) {
            #main-editor-container {
                display: flex; /* 确保是 flex 布局 */
                flex-wrap: nowrap; /* 不换行 */
            }
            .full-config-editor {
                display: flex; /* 默认显示 */
            }
        }

        /* 中等屏幕 (900px to 1199px - 隐藏完整配置编辑器，变为三列) */
        @media (max-width: 1199px) and (min-width: 900px) {
            #main-editor-container {
                display: grid; /* 使用 Grid 布局更方便控制列 */
                grid-template-columns: var(--calculated-func-btn-width, 150px) var(--calculated-hierarchy-width, 200px) 1fr;
                gap: var(--column-gap);
            }
            .full-config-editor {
                display: none; /* 隐藏完整配置编辑器 */
            }
        }

        /* 移动端 (<= 899px - 垂直堆叠，功能按钮横向排列，编辑器高度调整) */
        @media (max-width: 899px) {
            #main-editor-container {
                flex-direction: column; /* 垂直堆叠 */
                height: auto; /* 高度自适应 */
            }
            .functional-buttons-column {
                width: 100%; /* 占满宽度 */
                flex-direction: row; /* 功能按钮横向排列 */
                flex-wrap: wrap;
                justify-content: center;
            }
            .functional-buttons-column button {
                width: auto; /* 按钮宽度自适应内容 */
                flex-grow: 1; /* 按钮在行内平分空间 */
            }
            .editor-column {
                min-height: 200px; /* 确保每列有可见高度 */
                height: calc(100vh * var(--mobile-editor-height-ratio)); /* 调整编辑器高度 */
                overflow: hidden; /* 隐藏超出内容 */
            }
            .hierarchy-selector {
                width: 100%;
                flex-grow: 1;
            }
            .fragment-editor, .full-config-editor {
                width: 100%;
                flex-grow: 1;
                flex-basis: auto;
            }
            .full-config-editor {
                display: flex; /* 在移动端重新显示完整配置编辑器，但位置在最下方 */
            }
            #global-action-buttons {
                flex-direction: column; /* 按钮垂直堆叠 */
                align-items: stretch; /* 按钮宽度100% */
            }
            #global-action-buttons button {
                width: 100%;
            }
        }

        /* 模态框样式 */
        .modal {
            display: none; /* 默认隐藏 */
            position: fixed; /* 固定定位 */
            z-index: 1001; /* 确保在最上层 */
            left: 0;
            top: 0;
            width: 100%; /* 全屏 */
            height: 100%; /* 全屏 */
            overflow: auto; /* 允许滚动 */
            background-color: rgba(0,0,0,0.4); /* 半透明背景 */
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%; /* 模态框宽度 */
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        #modal-title {
            color: #007bff;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        #modal-message {
            white-space: pre-wrap; /* 保留换行符 */
            font-size: 0.95em;
            color: #555;
            max-height: 300px; /* 限制高度，允许滚动 */
            overflow-y: auto;
            padding-right: 5px; /* 防止滚动条遮挡文字 */
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        .modal-button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }

        .modal-button.confirm {
            background-color: #007bff;
            color: white;
        }

        .modal-button.confirm:hover {
            background-color: #0056b3;
        }

        /* 错误消息的特殊样式 */
        #modal-title.error {
            color: #dc3545;
        }
        #modal-message.error {
            color: #dc3545;
            font-weight: bold;
        }

        @media (max-width: 899px) {
            .modal-content {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <h1>Sing-box 配置编辑器</h1>

    <!-- 统一提示框 (Toast Notification) -->
    <div id="toast-notification" class="toast-notification"></div>

    <!-- 自定义模态框 (用于需要用户确认的错误/信息) -->
    <div id="notification-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="modal-actions">
                <button id="modal-confirm-button" class="modal-button confirm">确定</button>
            </div>
        </div>
    </div>

    <!-- 配置路径选择器容器 -->
    <div id="config-path-selector-container">
        <h2>选择 Sing-box 配置目录</h2>
        <p>系统已检测到以下可用路径:</p>
        <select id="config-path-select">
            <option value="" disabled selected>-- 正在加载可用路径 --</option>
            <!-- 动态加载路径选项 -->
        </select>
        <p>或手动输入:</p>
        <input type="text" id="manual-path-input" placeholder="/path/to/sing-box/conf/">
        <button id="set-path-button">设置此路径</button>
        <div class="current-active-path-info">当前活动路径: <span id="current-active-path-display">未设置</span></div>
        <p id="config-path-message" class="config-path-message"></p>
    </div>

    <!-- 主编辑器容器 (初始隐藏) -->
    <div id="main-editor-container" style="display: none;">
        <!-- 第一列：功能按钮区 - 竖向排列 -->
        <div class="functional-buttons-column" id="functional-buttons-column">
            <p class="message">请设置配置目录后加载功能按钮...</p>
        </div>

        <!-- 第二列：层级选择器 -->
        <div class="editor-column hierarchy-selector">
            <h2>配置层级</h2>
            <ul id="hierarchy-list">
                <p class="message">请点击左侧功能按钮加载层级。</p>
            </ul>
        </div>

        <!-- 第三列：片段编辑器 -->
        <div class="editor-column fragment-editor">
            <h2>片段编辑器</h2>
            <textarea id="fragment-content-area" placeholder="请从左侧选择一个配置层级以编辑其片段内容..."></textarea>
        </div>

        <!-- 第四列：完整配置编辑器 -->
        <div class="editor-column full-config-editor">
            <h2>完整配置编辑器</h2>
            <textarea id="full-config-content-area" placeholder="请从左侧功能按钮选择一个文件以查看其完整内容..."></textarea>
        </div>
    </div>

    <!-- 全局保存和重启按钮容器，放在三列之外 -->
    <div id="global-action-buttons" style="display: none;">
        <button id="save-config-button" disabled>仅保存配置</button>
        <button id="save-and-restart-button" disabled>保存并重启 Sing-box</button>
    </div>

    <div class="footer">
        <hr>
        <p>Go Web 服务正在运行。</p>
    </div>

    <script>
        // DOM 元素引用
        const toastNotification = document.getElementById('toast-notification');
        const notificationModal = document.getElementById('notification-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmButton = document.getElementById('modal-confirm-button');
        const closeModalButton = notificationModal.querySelector('.close-button');
        
        const configPathSelectorContainer = document.getElementById('config-path-selector-container');
        const configPathSelect = document.getElementById('config-path-select');
        const manualPathInput = document.getElementById('manual-path-input');
        const setPathButton = document.getElementById('set-path-button');
        const currentActivePathDisplay = document.getElementById('current-active-path-display');
        const configPathMessage = document.getElementById('config-path-message');

        const mainEditorContainer = document.getElementById('main-editor-container');
        const functionalButtonsColumn = document.getElementById('functional-buttons-column');
        const hierarchyList = document.getElementById('hierarchy-list');
        const hierarchySelectorColumn = document.querySelector('.hierarchy-selector');
        const fragmentContentArea = document.getElementById('fragment-content-area');
        const fullConfigContentArea = document.getElementById('full-config-content-area');
        
        const globalActionButtons = document.getElementById('global-action-buttons');
        const saveConfigButton = document.getElementById('save-config-button');
        const saveAndRestartButton = document.getElementById('save-and-restart-button');

        // 状态变量
        let currentFilename = '';
        let currentJsonPath = '';
        let currentRootContextKey = '';
        let activeTopButton = null;
        let activeHierarchyItem = null;
        let currentActiveConfigPath = '';

        // 辅助函数：显示自动消失的提示框 (Toast)
        function showToast(message, type = 'info', duration = 3000) {
            toastNotification.textContent = message;
            toastNotification.className = `toast-notification show ${type}`;
            clearTimeout(toastNotification.timer);
            toastNotification.timer = setTimeout(() => {
                toastNotification.classList.remove('show');
            }, duration);
        }

        // 辅助函数：显示需要用户确认的模态框
        function showModal(title, message, type = 'info') {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalTitle.className = type; // 用于设置标题颜色
            modalMessage.className = type; // 用于设置消息颜色
            notificationModal.classList.add('show');

            return new Promise(resolve => {
                const confirmHandler = () => {
                    notificationModal.classList.remove('show');
                    modalConfirmButton.removeEventListener('click', confirmHandler);
                    closeModalButton.removeEventListener('click', confirmHandler);
                    resolve(true);
                };
                modalConfirmButton.addEventListener('click', confirmHandler);
                closeModalButton.addEventListener('click', confirmHandler);
            });
        }

        // 辅助函数：显示提示信息在指定元素
        function showMessage(element, message, type = 'info') {
            element.innerHTML = `<p class="message ${type}">${message}</p>`;
        }
        function clearMessage(element) {
            element.innerHTML = '';
        }

        // 辅助函数：将JSON字符串格式化
        function formatJson(jsonString) {
            try {
                const obj = JSON.parse(jsonString);
                return JSON.stringify(obj, null, 2);
            } catch (e) {
                return jsonString;
            }
        }

        // ---------- API 调用函数 (与 Go 后端保持一致) ----------
        // 这些函数与上一个版本 main.go 提供的完全相同，为了简洁，这里只粘贴一份，请确保与 Go 后端代码一致
        async function fetchConfigPaths() {
            try {
                const response = await fetch('/api/get_config_paths');
                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`获取配置路径失败: ${errorJson.error || response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API /api/get_config_paths 失败:', error);
                configPathMessage.textContent = `获取可用配置路径失败: ${error.message}`;
                return { found_paths: [], systemd_default: '', current_active_path: '' };
            }
        }

        async function setActiveConfigPath(path) {
            try {
                const response = await fetch('/api/set_active_config_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });

                const result = await response.json();
                if (response.ok) {
                    return true;
                } else {
                    throw new Error(result.message || result.error || '未知错误');
                }
            } catch (error) {
                console.error('API /api/set_active_config_path 失败:', error);
                configPathMessage.textContent = `设置路径失败: ${error.message}`;
                return false;
            }
        }

        async function fetchFunctionalConfigs() {
            try {
                const response = await fetch('/api/get_functional_configs');
                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`获取功能配置失败: ${errorJson.error || response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API /api/get_functional_configs 失败:', error);
                showToast(`加载功能配置失败: ${error.message}\n请检查配置目录是否正确且可读。`, 'error');
                return { ordered_functional_config: [], config_files: [], active_config_path: '' };
            }
        }

        async function fetchTopKeys(filename) {
            try {
                const response = await fetch(`/api/get_top_keys?filename=${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`获取顶层键失败: ${errorJson.error || response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API /api/get_top_keys 失败:', error);
                showToast(`获取文件 '${filename}' 的顶层键失败: ${error.message}`, 'error');
                return { Keys: [] };
            }
        }

        async function fetchFileContent(filename, path = '') {
            try {
                let url = `/api/get_content?filename=${encodeURIComponent(filename)}`;
                if (path) {
                    url += `&path=${encodeURIComponent(path)}`;
                }
                const response = await fetch(url);
                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(`获取文件内容失败: ${errorJson.error || response.statusText}`);
                }
                return await response.text();
            } catch (error) {
                console.error('API /api/get_content 失败:', error);
                showToast(`获取文件 '${filename}' (路径: ${path}) 内容失败: ${error.message}`, 'error');
                return '';
            }
        }

        async function saveFileContent(filename, content, path = '') {
            try {
                const response = await fetch('/api/save_content', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename, content, path })
                });

                const result = await response.json();
                if (response.ok) {
                    showToast(`成功: ${result.message}`, 'success');
                    return true;
                } else {
                    showToast(`保存失败: ${result.message || result.error || '未知错误'}`, 'error');
                    console.error('API /api/save_content 失败:', result);
                    return false;
                }
            } catch (error) {
                showToast('网络错误或服务器无响应，保存失败。', 'error');
                console.error('API /api/save_content 网络请求失败:', error);
                return false;
            }
        }

        async function restartSingboxService() {
            try {
                const response = await fetch('/api/restart_singbox', { method: 'POST' });
                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.message || result.error || response.statusText);
                }
                return { success: true, message: result.message };
            } catch (error) {
                console.error('API /api/restart_singbox 失败:', error);
                return { success: false, message: error.message || '网络错误或服务器无响应。' };
            }
        }

        async function checkConfig() {
            try {
                const response = await fetch('/api/check_config', { method: 'POST' });
                const result = await response.json();
                if (!response.ok) {
                    // 后端在检查失败时也会返回 200 OK，但 status 为 error
                    // 所以这里主要处理网络错误或非JSON响应
                    throw new Error(result.message || result.error || response.statusText);
                }
                return result; // { status: "success" | "error", message: "..." }
            } catch (error) {
                console.error('API /api/check_config 失败:', error);
                return { status: "error", message: `配置检查请求失败: ${error.message || '网络错误或服务器无响应。'}` };
            }
        }
        // --------------------------------------------------------------------------------------


        // ---------- UI 宽度计算函数 ----------
        function calculateFunctionalButtonWidth(buttonsData) {
            if (!buttonsData || buttonsData.length === 0) {
                functionalButtonsColumn.style.width = `var(--func-button-min-width)`;
                return;
            }

            // 在移动端 (max-width: 899px)，功能按钮是横向排列的，不需要计算固定宽度
            if (window.matchMedia('(max-width: 899px)').matches) {
                 functionalButtonsColumn.style.width = '100%';
                 return;
            }

            let maxWidth = 0;
            const tempSpan = document.createElement('span');
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute';
            tempSpan.style.whiteSpace = 'normal'; // 允许换行来测量
            tempSpan.style.wordBreak = 'break-all';
            tempSpan.style.fontFamily = 'Arial, sans-serif';
            tempSpan.style.fontSize = '0.95rem';
            // 复制按钮的padding和box-sizing
            tempSpan.style.padding = '10px 15px';
            tempSpan.style.boxSizing = 'border-box';
            // 设置一个最大宽度，模拟6个字符换行
            const charWidthEstimate = 9; // 估算一个字符的宽度
            const maxCharsBeforeBreak = 6;
            tempSpan.style.maxWidth = `${maxCharsBeforeBreak * charWidthEstimate + 15 * 2}px`; // 6字符 + padding

            document.body.appendChild(tempSpan);

            buttonsData.forEach(config => {
                tempSpan.textContent = config.FunctionName;
                // 计算出实际渲染的宽度
                maxWidth = Math.max(maxWidth, tempSpan.offsetWidth);
            });

            document.body.removeChild(tempSpan);

            // 最终宽度至少为最小宽度
            const finalWidth = Math.max(maxWidth, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--func-button-min-width')));

            functionalButtonsColumn.style.width = `${finalWidth}px`;
        }

        function calculateHierarchyColumnWidth(itemsData) {
            if (!itemsData || itemsData.length === 0) {
                hierarchySelectorColumn.style.flexBasis = 'auto';
                hierarchySelectorColumn.style.maxWidth = `calc(100% * var(--hierarchy-max-width-ratio))`;
                return;
            }

            // 在移动端，层级选择器宽度是100%
            if (window.matchMedia('(max-width: 899px)').matches) {
                hierarchySelectorColumn.style.flexBasis = '100%';
                hierarchySelectorColumn.style.maxWidth = '100%';
                return;
            }

            let maxWidth = 0;
            const tempSpan = document.createElement('span');
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute';
            tempSpan.style.whiteSpace = 'normal'; // 允许换行
            tempSpan.style.wordBreak = 'break-all';
            tempSpan.style.fontFamily = 'Courier New, monospace';
            tempSpan.style.fontSize = '0.9em';
            // 复制列表项的padding和box-sizing
            tempSpan.style.padding = '8px 10px';
            tempSpan.style.boxSizing = 'border-box';
            
            document.body.appendChild(tempSpan);

            itemsData.forEach(key => {
                tempSpan.textContent = key;
                maxWidth = Math.max(maxWidth, tempSpan.offsetWidth);
            });

            document.body.removeChild(tempSpan);

            const columnPadding = parseFloat(getComputedStyle(hierarchySelectorColumn).paddingLeft) + parseFloat(getComputedStyle(hierarchySelectorColumn).paddingRight);
            const calculatedWidth = maxWidth + columnPadding + 20; // 额外增加20px余量
            
            // 获取 mainEditorContainer 的动态宽度
            const mainEditorContainerWidth = mainEditorContainer.offsetWidth;
            const maxWidthLimit = mainEditorContainerWidth * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hierarchy-max-width-ratio'));

            hierarchySelectorColumn.style.flexGrow = '0';
            hierarchySelectorColumn.style.flexBasis = `${Math.min(calculatedWidth, maxWidthLimit)}px`;
            hierarchySelectorColumn.style.maxWidth = `${maxWidthLimit}px`;
        }


        // ---------- UI 更新函数 ----------

        // 高亮顶部功能按钮
        function highlightTopButton(button) {
            if (activeTopButton) {
                activeTopButton.classList.remove('active');
            }
            if (button) {
                button.classList.add('active');
                activeTopButton = button;
            } else {
                activeTopButton = null;
            }
        }

        // 高亮层级列表项
        function highlightHierarchyItem(item) {
            if (activeHierarchyItem) {
                activeHierarchyItem.classList.remove('active');
            }
            if (item) {
                item.classList.add('active');
                activeHierarchyItem = item;
            } else {
                activeHierarchyItem = null;
            }
        }

        // 禁用/启用保存按钮
        function setSaveButtonsState(enabled) {
            saveConfigButton.disabled = !enabled;
            saveAndRestartButton.disabled = !enabled;
        }

        // ---------- 事件处理函数 ----------

        // 加载配置路径选择器界面
        async function loadConfigPathSelector() {
            console.log('loadConfigPathSelector() called');
            configPathSelectorContainer.style.display = 'flex';
            mainEditorContainer.style.display = 'none';
            globalActionButtons.style.display = 'none';
            setPathButton.disabled = true;
            configPathSelect.innerHTML = '<option value="" disabled selected>-- 正在加载可用路径 --</option>';

            console.log('Calling fetchConfigPaths...');
            const pathResponse = await fetchConfigPaths();
            console.log('fetchConfigPaths response:', pathResponse);
            const foundPaths = pathResponse.found_paths || [];
            const systemdDefault = pathResponse.systemd_default || '';
            currentActiveConfigPath = pathResponse.current_active_path || '';

            console.log('Found paths:', foundPaths);
            console.log('Systemd default:', systemdDefault);
            console.log('Current active path:', currentActiveConfigPath);

            configPathSelect.innerHTML = '<option value="" disabled selected>-- 请选择一个路径 --</option>';
            if (foundPaths.length === 0) {
                configPathMessage.textContent = '未检测到任何可用的 Sing-box 配置目录。请手动输入。';
                setPathButton.disabled = false;
            } else {
                foundPaths.forEach(path => {
                    const option = document.createElement('option');
                    option.value = path;
                    option.textContent = path;
                    configPathSelect.appendChild(option);
                });
                configPathSelect.disabled = false;
                setPathButton.disabled = false;
            }

            if (systemdDefault && foundPaths.includes(systemdDefault)) {
                manualPathInput.value = systemdDefault;
            }

            currentActivePathDisplay.textContent = currentActiveConfigPath || '未设置';

            if (currentActiveConfigPath) {
                configPathMessage.textContent = `已自动设置配置目录为：${currentActiveConfigPath}`;
                await loadEditorUI();
            } else if (foundPaths.length === 1 && !systemdDefault) {
                configPathSelect.value = foundPaths[0];
                manualPathInput.value = foundPaths[0];
                configPathMessage.textContent = `检测到唯一路径，尝试自动设置：${foundPaths[0]}`;
                const success = await setActiveConfigPath(foundPaths[0]);
                if (success) {
                    currentActiveConfigPath = foundPaths[0];
                    currentActivePathDisplay.textContent = currentActiveConfigPath;
                    await loadEditorUI();
                }
            } else {
                configPathMessage.textContent = '请选择或手动输入 Sing-box 配置目录。';
            }
        }

        // 处理设置路径按钮点击
        async function handleSetConfigPathClick() {
            console.log('handleSetConfigPathClick() called');
            clearMessage(configPathMessage);
            let selectedPath = configPathSelect.value;
            if (!selectedPath) {
                selectedPath = manualPathInput.value.trim();
            }

            if (!selectedPath) {
                configPathMessage.textContent = '请选择或输入一个有效的配置目录路径。';
                return;
            }

            const success = await setActiveConfigPath(selectedPath);
            if (success) {
                currentActiveConfigPath = selectedPath;
                currentActivePathDisplay.textContent = currentActiveConfigPath;
                await loadEditorUI();
            }
        }

        // 加载编辑器UI (功能按钮, 清空编辑器)
        async function loadEditorUI() {
            console.log('loadEditorUI() called');
            configPathSelectorContainer.style.display = 'none';
            mainEditorContainer.style.display = 'flex';
            globalActionButtons.style.display = 'flex';

            functionalButtonsColumn.innerHTML = '<p class="message">正在加载功能配置...</p>';
            hierarchyList.innerHTML = '<p class="message">请点击左侧功能按钮加载层级。</p>';
            fragmentContentArea.value = '';
            fragmentContentArea.placeholder = '请从左侧选择一个配置层级以编辑其片段内容...';
            fullConfigContentArea.value = '';
            fullConfigContentArea.placeholder = '请从左侧功能按钮选择一个文件以查看其完整内容...';

            setSaveButtonsState(false);
            highlightTopButton(null);
            highlightHierarchyItem(null);

            console.log('Calling fetchFunctionalConfigs...');
            const funcConfigResponse = await fetchFunctionalConfigs();
            console.log('fetchFunctionalConfigs response:', funcConfigResponse);
            const orderedFunctionalConfig = funcConfigResponse.ordered_functional_config || [];

            if (orderedFunctionalConfig.length > 0) {
                functionalButtonsColumn.innerHTML = '';
                calculateFunctionalButtonWidth(orderedFunctionalConfig); // 计算并设置宽度

                orderedFunctionalConfig.forEach(config => {
                    const button = document.createElement('button');
                    button.classList.add('config-type-button');
                    button.dataset.filename = config.FileName;
                    button.textContent = config.FunctionName;
                    functionalButtonsColumn.appendChild(button);
                });
            } else {
                showMessage(functionalButtonsColumn, '没有识别到任何功能配置文件，请检查配置目录。');
            }

            if (currentFilename && activeTopButton) {
                handleFunctionalButtonClick({ target: activeTopButton });
            } else {
                 // 如果没有选中文件，清空层级列表的宽度设置
                hierarchySelectorColumn.style.flexBasis = 'auto';
                hierarchySelectorColumn.style.maxWidth = `calc(100% * var(--hierarchy-max-width-ratio))`;
            }
        }

        // 处理顶部功能按钮点击 (加载文件和顶层键)
        async function handleFunctionalButtonClick(event) {
            console.log('handleFunctionalButtonClick() called');
            const button = event.target.closest('.config-type-button');
            if (!button) return;

            console.log('Functional button clicked:', button.textContent, 'filename:', button.dataset.filename);
            highlightTopButton(button);
            currentFilename = button.dataset.filename;
            currentJsonPath = ''; // 确保在选择新文件时清空片段路径
            currentRootContextKey = '';

            fragmentContentArea.value = '';
            fragmentContentArea.placeholder = '请从左侧选择一个配置层级以编辑其片段内容...';
            highlightHierarchyItem(null);

            showMessage(hierarchyList, '正在加载...');
            fullConfigContentArea.value = '正在加载...';

            console.log('Calling fetchTopKeys for filename:', currentFilename);
            const topKeysResponse = await fetchTopKeys(currentFilename);
            console.log('fetchTopKeys response:', topKeysResponse);
            currentRootContextKey = topKeysResponse.root_context_key || '';
            const topKeys = topKeysResponse.keys || [];

            if (topKeys.length > 0) {
                hierarchyList.innerHTML = '';
                topKeys.forEach(key => {
                    const li = document.createElement('li');
                    li.textContent = key;
                    li.dataset.jsonPath = currentRootContextKey ? `${currentRootContextKey}.${key}` : key;
                    hierarchyList.appendChild(li);
                });
                calculateHierarchyColumnWidth(topKeys); // 计算并设置层级列表宽度
            } else {
                showMessage(hierarchyList, `文件 '${currentFilename}' 没有有效的顶层键或不是JSON对象。`);
                // 如果没有层级，还原层级列宽度设置
                hierarchySelectorColumn.style.flexBasis = 'auto';
                hierarchySelectorColumn.style.maxWidth = `calc(100% * var(--hierarchy-max-width-ratio))`;
            }

            console.log('Calling fetchFileContent for filename:', currentFilename);
            const fullContent = await fetchFileContent(currentFilename);
            console.log('fetchFileContent (full) response length:', fullContent.length);
            fullConfigContentArea.value = formatJson(fullContent);
            fullConfigContentArea.focus();
            setSaveButtonsState(true);
            saveConfigButton.textContent = '仅保存配置'; // 更新按钮文本
        }

        // 处理第二列层级点击 (加载片段内容)
        async function handleHierarchyItemClick(event) {
            console.log('handleHierarchyItemClick() called');
            const listItem = event.target.closest('li');
            if (!listItem || !currentFilename) return;

            console.log('Hierarchy item clicked:', listItem.textContent, 'jsonPath:', listItem.dataset.jsonPath);
            highlightHierarchyItem(listItem);
            currentJsonPath = listItem.dataset.jsonPath;

            fragmentContentArea.value = '正在加载片段内容...';
            setSaveButtonsState(false);

            console.log('Calling fetchFileContent for filename:', currentFilename, 'path:', currentJsonPath);
            const fragmentContent = await fetchFileContent(currentFilename, currentJsonPath);
            console.log('fetchFileContent (fragment) response length:', fragmentContent.length);
            fragmentContentArea.value = formatJson(fragmentContent);
            fragmentContentArea.focus();
            setSaveButtonsState(true);
            saveConfigButton.textContent = '保存片段'; // 更新按钮文本
        }

        // 核心保存逻辑
        // 返回 { success: boolean, message: string }
        async function performSave(filename, content, path = '') {
            console.log('performSave() called with filename:', filename, 'path:', path, 'content length:', content.length);
            if (!filename) {
                console.error('performSave: filename is empty');
                return { success: false, message: '请先选择一个文件！' };
            }
            if (!content) {
                return { success: false, message: '内容不能为空！' };
            }

            try {
                const response = await fetch('/api/save_content', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename, content, path })
                });

                const result = await response.json();
                if (response.ok) {
                    return { success: true, message: result.message };
                } else {
                    return { success: false, message: result.message || result.error || '未知错误' };
                }
            } catch (error) {
                console.error('API /api/save_content 网络请求失败:', error);
                return { success: false, message: '网络错误或服务器无响应，保存失败。' };
            }
        }

        // 刷新编辑器内容
        async function refreshEditorContent(isFullFileSave = false) {
            if (!currentFilename) return;

            const fullContent = await fetchFileContent(currentFilename);
            fullConfigContentArea.value = formatJson(fullContent);

            if (isFullFileSave) {
                // 如果是完整文件保存，重新加载功能按钮和清空片段编辑器
                await loadEditorUI();
                if (activeTopButton) {
                    handleFunctionalButtonClick({ target: activeTopButton });
                }
                fragmentContentArea.value = '';
                fragmentContentArea.placeholder = '请从左侧选择一个配置层级以编辑其片段内容...';
                highlightHierarchyItem(null);
            } else if (currentJsonPath) {
                // 如果是片段保存，只刷新片段编辑器
                const fragmentContent = await fetchFileContent(currentFilename, currentJsonPath);
                fragmentContentArea.value = formatJson(fragmentContent);
            }
        }

        // 处理“保存片段”按钮点击
        async function handleSaveFragment() {
            console.log('handleSaveFragment() called');
            if (!currentFilename || !currentJsonPath) {
                showToast('请先选择一个文件和配置片段！', 'error');
                return;
            }

            const contentToSave = fragmentContentArea.value;
            const saveResult = await performSave(currentFilename, contentToSave, currentJsonPath);

            if (saveResult.success) {
                console.log('Save successful, refreshing editor content...');
                await refreshEditorContent(false); // 刷新片段和完整文件编辑器

                console.log('Calling checkConfig after fragment save...');
                const checkResult = await checkConfig();
                console.log('checkConfig result:', checkResult);
                if (checkResult.status === "success") {
                    showToast(`${saveResult.message} 且配置检查成功，无错误！`, 'success'); // 合并成功提示
                } else {
                    await showModal('配置检查失败', checkResult.message, 'error');
                    showToast(`保存成功，但配置检查失败。`, 'error'); // 增加一个 Toast 提示
                }
            } else {
                console.error('Fragment save failed:', saveResult.message);
                showToast(`保存失败: ${saveResult.message}`, 'error');
            }
        }

        // 处理“保存完整文件”按钮点击
        async function handleSaveFullFile() {
            console.log('handleSaveFullFile() called');
            if (!currentFilename) {
                showToast('请先选择一个文件！', 'error');
                return;
            }

            const contentToSave = fullConfigContentArea.value;
            const saveResult = await performSave(currentFilename, contentToSave);

            if (saveResult.success) {
                console.log('Save successful, refreshing editor content...');
                await refreshEditorContent(true); // 刷新整个UI

                console.log('Calling checkConfig after full file save...');
                const checkResult = await checkConfig();
                console.log('checkConfig result:', checkResult);
                if (checkResult.status === "success") {
                    showToast(`${saveResult.message} 且配置检查成功，无错误！`, 'success'); // 合并成功提示
                } else {
                    await showModal('配置检查失败', checkResult.message, 'error');
                    showToast(`保存成功，但配置检查失败。`, 'error'); // 增加一个 Toast 提示
                }
            } else {
                console.error('Full file save failed:', saveResult.message);
                showToast(`保存失败: ${saveResult.message}`, 'error');
            }
        }

        // 处理“保存并重启 Sing-box”按钮点击
        async function handleRestartSingbox() {
            console.log('handleRestartSingbox() called');
            if (!currentFilename) {
                showToast('请先选择一个文件进行保存！', 'error');
                return;
            }

            // 总是保存当前选中的完整文件内容
            const contentToSave = fullConfigContentArea.value;
            console.log('Calling performSave for full file before restart...');
            const saveResult = await performSave(currentFilename, contentToSave);
            console.log('performSave result before restart:', saveResult);

            if (saveResult.success) {
                showToast('配置保存成功，正在检查...', 'info');
                await refreshEditorContent(true); // 刷新整个UI

                console.log('Calling checkConfig before restart...');
                const checkResult = await checkConfig();
                console.log('checkConfig result before restart:', checkResult);
                if (checkResult.status === "success") {
                    showToast('配置检查成功，正在重启 Sing-box...', 'info');
                    console.log('Calling restartSingboxService...');
                    const restartResult = await restartSingboxService();
                    console.log('restartSingboxService result:', restartResult);
                    if (restartResult.success) {
                        showToast(`${saveResult.message}、检查无误并已重启 Sing-box！`, 'success'); // 合并最终成功提示
                    } else {
                        showToast(`重启失败: ${restartResult.message}`, 'error');
                    }
                } else {
                    await showModal('配置检查失败', checkResult.message, 'error');
                    showToast('配置检查失败，未执行重启操作。', 'error');
                }
            } else {
                console.error('Save failed before restart:', saveResult.message);
                showToast(`保存失败: ${saveResult.message}，未执行检查和重启操作。`, 'error');
            }
        }


        // ---------- 初始化 ----------
        function init() {
            console.log('init() called');
            // 配置路径选择器事件
            configPathSelect.addEventListener('change', () => {
                manualPathInput.value = configPathSelect.value;
                setPathButton.disabled = false;
                clearMessage(configPathMessage);
            });
            manualPathInput.addEventListener('input', () => {
                setPathButton.disabled = manualPathInput.value.trim() === '';
                clearMessage(configPathMessage);
            });
            setPathButton.addEventListener('click', handleSetConfigPathClick);

            // 编辑器相关事件
            functionalButtonsColumn.addEventListener('click', handleFunctionalButtonClick);
            hierarchyList.addEventListener('click', handleHierarchyItemClick);
            
            // 新增一个函数来处理保存按钮的点击，根据当前状态决定调用哪个保存函数
            async function handleSaveButtonClick() {
                console.log('handleSaveButtonClick() called. currentJsonPath:', currentJsonPath);
                if (currentJsonPath) {
                    await handleSaveFragment();
                } else {
                    await handleSaveFullFile();
                }
            }
            saveConfigButton.addEventListener('click', handleSaveButtonClick);
            // 将“保存并重启 Sing-box”按钮的点击事件绑定到 handleRestartSingbox
            saveAndRestartButton.addEventListener('click', handleRestartSingbox);

            // 移除片段编辑器和完整配置编辑器的 blur 事件监听器，保存操作应由按钮明确触发
            // fragmentContentArea.addEventListener('blur', handleSaveFragment);
            // fullConfigContentArea.addEventListener('blur', handleSaveFullFile);

            setSaveButtonsState(false);
            loadConfigPathSelector();

            // 监听窗口大小变化以重新计算列宽（如果需要响应式调整）
            window.addEventListener('resize', () => {
                if (mainEditorContainer.style.display !== 'none' && currentFilename) {
                    // 只有在编辑器显示时才重新计算
                    fetchFunctionalConfigs().then(funcConfigResponse => {
                        calculateFunctionalButtonWidth(funcConfigResponse.ordered_functional_config || []);
                    });
                    // 重新计算层级宽度需要知道 topKeys
                    if (activeTopButton) {
                        fetchTopKeys(currentFilename).then(topKeysResponse => {
                            calculateHierarchyColumnWidth(topKeysResponse.keys || []);
                        });
                    }
                }
            });
        }

        // 页面加载完成时执行初始化
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
